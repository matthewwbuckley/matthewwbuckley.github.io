// Perlin-style noise (simplified)
const c = document.getElementById('pixel-canvas');
const scale = 4;
c.width = Math.ceil(window.innerWidth / scale);
c.height = Math.ceil(window.innerHeight / scale);
c.style.width = window.innerWidth + 'px';
c.style.height = window.innerHeight + 'px';
c.style.position = 'fixed';
c.style.top = '0';
c.style.left = '0';
c.style.zIndex = '-1';
c.style.imageRendering = 'pixelated';

const ctx = c.getContext('2d');

const colors = ['#264653', '#e9c46a', '#2a9d8f', '#f4a261', '#0d1b2a', '#e0e1dd', '#415a77', '#1a1a2e', '#f4d35e', '#e94560'];
let currentColor = colors[~~(Math.random() * colors.length)];

// Switch color every 5 seconds
setInterval(() => {
  currentColor = colors[~~(Math.random() * colors.length)];
}, 5000);

// Simplified noise function (not true Perlin but similar effect)
function noise(x, y) {
  const n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
  return n - Math.floor(n);
}

function smoothNoise(x, y, scale) {
  const X = Math.floor(x / scale);
  const Y = Math.floor(y / scale);
  const fracX = (x / scale) - X;
  const fracY = (y / scale) - Y;

  const v1 = noise(X, Y);
  const v2 = noise(X + 1, Y);
  const v3 = noise(X, Y + 1);
  const v4 = noise(X + 1, Y + 1);

  const i1 = v1 * (1 - fracX) + v2 * fracX;
  const i2 = v3 * (1 - fracX) + v4 * fracX;

  return i1 * (1 - fracY) + i2 * fracY;
}

let offset = 0;

function draw() {
  offset += 0.05;

  for (let i = 0; i < 1000; i++) {
    const x = ~~(Math.random() * c.width);
    const y = ~~(Math.random() * c.height);

    const n = smoothNoise(x + offset * 10, y, 10);

    if (n > 0.5) {
      ctx.fillStyle = '#264653';
      ctx.fillRect(x, y, 1, 1);
    } else {
      ctx.clearRect(x, y, 1, 1); // erase when noise is low
    }
  }
}

setInterval(draw, 30);
